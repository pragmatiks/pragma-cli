"""Tests for CLI providers commands."""

import json
import tarfile
from datetime import UTC, datetime
from io import BytesIO

import httpx
import pytest
import yaml
from pragma_sdk import (
    BuildInfo,
    BuildStatus,
    DeploymentStatus,
    ProviderInfo,
    PushResult,
)
from pragma_sdk.models import ProviderStatus
from pytest_mock import MockerFixture
from typer.testing import CliRunner

from pragma_cli.commands.providers import (
    DEFAULT_TEMPLATE_URL,
    TARBALL_EXCLUDES,
    create_tarball,
    detect_provider_package,
    get_template_source,
)
from pragma_cli.main import app


@pytest.fixture
def cli_runner():
    return CliRunner()


@pytest.fixture
def template_path(monkeypatch, tmp_path):
    """Create and use a minimal Copier template for testing.

    Creates a self-contained template in a temp directory so tests
    don't depend on external template repos.
    """
    template_dir = tmp_path / "template"
    template_dir.mkdir()

    # Copier configuration
    copier_yml = template_dir / "copier.yml"
    copier_yml.write_text("""name:
  type: str
  help: Provider name
description:
  type: str
  default: "A Pragmatiks provider"
author_name:
  type: str
  default: "Test Author"
author_email:
  type: str
  default: "test@example.com"

_subdirectory: template
""")

    # Template subdirectory with Jinja2 files
    tpl_dir = template_dir / "template"
    tpl_dir.mkdir()

    # pyproject.toml template
    (tpl_dir / "pyproject.toml.jinja").write_text("""[project]
name = "{{ name }}-provider"
version = "0.1.0"
description = "{{ description }}"
dependencies = ["pragmatiks-sdk>=0.1.0"]

[project.optional-dependencies]
dev = ["pytest"]
""")

    # README template
    (tpl_dir / "README.md.jinja").write_text("""# {{ name }}-provider

{{ description }}
""")

    # Source directory structure
    src_dir = tpl_dir / "src" / "{{ name }}_provider"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""{{ name }} provider."""\n')

    resources_dir = src_dir / "resources"
    resources_dir.mkdir()
    (resources_dir / "__init__.py").write_text('"""Resource definitions."""\n')

    # Tests directory
    tests_dir = tpl_dir / "tests"
    tests_dir.mkdir()
    (tests_dir / "conftest.py").write_text('"""Test configuration."""\nimport pytest\n')

    # Copier answers file template (needed for update support)
    (tpl_dir / ".copier-answers.yml.jinja").write_text("""# This file was auto-generated by Copier
_src_path: {{ _copier_conf.src_path }}
name: {{ name }}
description: {{ description }}
author_name: {{ author_name }}
author_email: {{ author_email }}
""")

    monkeypatch.setenv("PRAGMA_PROVIDER_TEMPLATE", str(template_dir))
    return template_dir


@pytest.fixture
def mock_pragma_client(mocker: MockerFixture):
    """Mock get_client for testing."""
    mock_client = mocker.Mock()
    mock_client._auth = mocker.Mock()  # Simulate authenticated client
    mocker.patch("pragma_cli.commands.providers.get_client", return_value=mock_client)
    return mock_client


@pytest.fixture
def provider_project(tmp_path, monkeypatch):
    """Create a minimal provider project structure."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text('[project]\nname = "test-provider"')

    src_dir = tmp_path / "src" / "test_provider"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text("")
    (src_dir / "resources.py").write_text("# Resources go here")

    monkeypatch.chdir(tmp_path)
    return tmp_path


def test_get_template_source_uses_env_variable(monkeypatch):
    """Returns environment variable value when set."""
    monkeypatch.setenv("PRAGMA_PROVIDER_TEMPLATE", "/custom/template/path")
    assert get_template_source() == "/custom/template/path"


def test_get_template_source_default():
    """Default template URL is GitHub."""
    assert DEFAULT_TEMPLATE_URL == "gh:pragmatiks/pragma-providers"


def test_init_creates_project_structure(cli_runner, tmp_path, template_path):
    """Init creates complete project structure with all expected files."""
    result = cli_runner.invoke(
        app,
        ["providers", "init", "mycompany", "--output", str(tmp_path / "mycompany-provider"), "--defaults"],
    )
    assert result.exit_code == 0

    project_dir = tmp_path / "mycompany-provider"
    assert project_dir.exists()
    assert (project_dir / "pyproject.toml").exists()
    assert (project_dir / "README.md").exists()
    assert (project_dir / ".copier-answers.yml").exists()
    assert (project_dir / "src" / "mycompany_provider" / "__init__.py").exists()
    assert (project_dir / "src" / "mycompany_provider" / "resources" / "__init__.py").exists()
    assert (project_dir / "tests" / "conftest.py").exists()

    pyproject = (project_dir / "pyproject.toml").read_text()
    assert "pragmatiks-sdk" in pyproject

    assert "uv sync" in result.stdout
    assert "pragma providers push" in result.stdout


def test_init_fails_if_directory_exists(cli_runner, tmp_path, template_path):
    """Init fails if target directory already exists."""
    existing_dir = tmp_path / "existing-provider"
    existing_dir.mkdir()

    result = cli_runner.invoke(app, ["providers", "init", "existing", "--output", str(existing_dir)])
    assert result.exit_code == 1
    assert "already exists" in result.output


def test_update_fails_without_answers_file(cli_runner, tmp_path):
    """Update fails when .copier-answers.yml is missing."""
    result = cli_runner.invoke(app, ["providers", "update", str(tmp_path)])
    assert result.exit_code == 1
    assert "not a Copier-generated project" in result.output


def test_push_fails_without_pyproject(cli_runner, tmp_path, monkeypatch):
    """Push fails when no pyproject.toml exists."""
    monkeypatch.chdir(tmp_path)
    result = cli_runner.invoke(app, ["providers", "push"])
    assert result.exit_code == 1
    assert "Could not detect provider package" in result.output


def test_push_uploads_tarball_and_polls_status(cli_runner, provider_project, mock_pragma_client):
    """Push creates tarball, uploads to API, and polls for completion."""
    mock_pragma_client.push_provider.return_value = PushResult(
        version="20250114.153045",
        job_name="build-test-20250114153045",
        status=BuildStatus.PENDING,
        message="Build started",
    )
    mock_pragma_client.get_build_status.return_value = BuildInfo(
        provider_id="test",
        version="20250114.153045",
        status=BuildStatus.SUCCESS,
        created_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
    )

    result = cli_runner.invoke(app, ["providers", "push"])

    assert result.exit_code == 0
    assert "Pushing provider: test" in result.output
    assert "Created tarball:" in result.output
    assert "Build started:" in result.output
    assert "Build successful:" in result.output

    mock_pragma_client.push_provider.assert_called_once()
    call_args = mock_pragma_client.push_provider.call_args
    assert call_args[0][0] == "test"  # provider_id
    assert isinstance(call_args[0][1], bytes)  # tarball


def test_push_with_deploy_flag_deploys_after_build(cli_runner, provider_project, mock_pragma_client):
    """Push with --deploy deploys after successful build."""
    mock_pragma_client.push_provider.return_value = PushResult(
        version="20250114.153045",
        job_name="build-test-20250114153045",
        status=BuildStatus.PENDING,
        message="Build started",
    )
    mock_pragma_client.get_build_status.return_value = BuildInfo(
        provider_id="test",
        version="20250114.153045",
        status=BuildStatus.SUCCESS,
        created_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
    )
    mock_pragma_client.deploy_provider.return_value = ProviderStatus(
        status=DeploymentStatus.PROGRESSING,
        version="20250114.153045",
        updated_at=None,
        healthy=False,
    )

    result = cli_runner.invoke(app, ["providers", "push", "--deploy"])

    assert result.exit_code == 0
    assert "Deployment started:" in result.output
    # Deploy is called with version from push result, not image from build
    mock_pragma_client.deploy_provider.assert_called_once_with("test", "20250114.153045")


def test_push_with_no_wait_returns_immediately(cli_runner, provider_project, mock_pragma_client):
    """Push with --no-wait returns immediately after upload."""
    mock_pragma_client.push_provider.return_value = PushResult(
        version="20250114.153045",
        job_name="build-test-20250114153045",
        status=BuildStatus.PENDING,
        message="Build started",
    )

    result = cli_runner.invoke(app, ["providers", "push", "--no-wait"])

    assert result.exit_code == 0
    assert "Build running in background" in result.output
    mock_pragma_client.get_build_status.assert_not_called()


def test_push_handles_build_failure(cli_runner, provider_project, mock_pragma_client):
    """Push handles build failures gracefully."""
    mock_pragma_client.push_provider.return_value = PushResult(
        version="20250114.153045",
        job_name="build-test-20250114153045",
        status=BuildStatus.PENDING,
        message="Build started",
    )
    mock_pragma_client.get_build_status.return_value = BuildInfo(
        provider_id="test",
        version="20250114.153045",
        status=BuildStatus.FAILED,
        error_message="Dockerfile syntax error",
        created_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
    )

    result = cli_runner.invoke(app, ["providers", "push"])

    assert result.exit_code == 1
    assert "Build failed:" in result.output
    assert "Dockerfile syntax error" in result.output


def test_push_with_package_option_uses_specified_name(cli_runner, tmp_path, mock_pragma_client, monkeypatch):
    """Push uses --package option instead of detecting from pyproject."""
    monkeypatch.chdir(tmp_path)
    (tmp_path / "pyproject.toml").write_text('[project]\nname = "other-provider"')

    mock_pragma_client.push_provider.return_value = PushResult(
        version="20250114.153045",
        job_name="build-test-20250114153045",
        status=BuildStatus.PENDING,
        message="Build started",
    )
    mock_pragma_client.get_build_status.return_value = BuildInfo(
        provider_id="custom-provider",
        version="20250114.153045",
        status=BuildStatus.SUCCESS,
        created_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
    )

    result = cli_runner.invoke(app, ["providers", "push", "--package", "custom_provider"])

    assert result.exit_code == 0
    assert "Pushing provider: custom" in result.output
    mock_pragma_client.push_provider.assert_called_once()
    assert mock_pragma_client.push_provider.call_args[0][0] == "custom"


def test_create_tarball_includes_source_files(tmp_path):
    """Tarball includes provider source files."""
    src_dir = tmp_path / "src"
    src_dir.mkdir()
    (src_dir / "main.py").write_text("print('hello')")
    (tmp_path / "pyproject.toml").write_text('[project]\nname = "test"')

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert "./src/main.py" in names or "src/main.py" in names
        assert "./pyproject.toml" in names or "pyproject.toml" in names


def test_create_tarball_excludes_git_directory(tmp_path):
    """Tarball excludes .git directory."""
    (tmp_path / ".git").mkdir()
    (tmp_path / ".git" / "config").write_text("git config")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any(".git" in name for name in names)


def test_create_tarball_excludes_pycache(tmp_path):
    """Tarball excludes __pycache__ directories."""
    pycache = tmp_path / "__pycache__"
    pycache.mkdir()
    (pycache / "module.cpython-313.pyc").write_bytes(b"bytecode")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any("__pycache__" in name for name in names)


def test_create_tarball_excludes_venv(tmp_path):
    """Tarball excludes .venv directory."""
    venv = tmp_path / ".venv"
    venv.mkdir()
    (venv / "pyvenv.cfg").write_text("home = /usr/bin")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any(".venv" in name for name in names)


def test_create_tarball_excludes_pyc_files(tmp_path):
    """Tarball excludes .pyc files."""
    (tmp_path / "module.pyc").write_bytes(b"bytecode")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any(".pyc" in name for name in names)


def test_tarball_excludes_contains_common_patterns():
    """TARBALL_EXCLUDES contains expected patterns."""
    expected = {".git", "__pycache__", ".venv", ".env", "*.pyc", "dist", "build"}
    assert expected.issubset(TARBALL_EXCLUDES)


def test_detect_provider_package_from_pyproject(tmp_path, monkeypatch):
    """Detects package name from pyproject.toml."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text('[project]\nname = "postgres-provider"')
    monkeypatch.chdir(tmp_path)

    result = detect_provider_package()
    assert result == "postgres_provider"


def test_detect_provider_package_returns_none_without_pyproject(tmp_path, monkeypatch):
    """Returns None when no pyproject.toml exists."""
    monkeypatch.chdir(tmp_path)
    result = detect_provider_package()
    assert result is None


def test_status_displays_deployment_info(cli_runner, mock_pragma_client):
    """Status command displays deployment information."""
    mock_pragma_client.get_deployment_status.return_value = ProviderStatus(
        status=DeploymentStatus.AVAILABLE,
        version="20250114.153045",
        updated_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
        healthy=True,
    )

    result = cli_runner.invoke(app, ["providers", "status", "test"])

    assert result.exit_code == 0
    assert "Provider:" in result.output
    assert "test" in result.output
    assert "available" in result.output
    assert "2025-01-14" in result.output
    assert "yes" in result.output  # healthy status


def test_status_handles_not_found(cli_runner, mock_pragma_client):
    """Status command handles deployment not found."""
    mock_response = httpx.Response(404, json={"detail": "Deployment not found"})
    mock_pragma_client.get_deployment_status.side_effect = httpx.HTTPStatusError(
        "Not found", request=httpx.Request("GET", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "status", "nonexistent"])

    assert result.exit_code == 1
    assert "Deployment not found" in result.output


def test_status_handles_progressing_deployment(cli_runner, mock_pragma_client):
    """Status command shows progressing status correctly."""
    mock_pragma_client.get_deployment_status.return_value = ProviderStatus(
        status=DeploymentStatus.PROGRESSING,
        version="20250114.160000",
        healthy=False,
    )

    result = cli_runner.invoke(app, ["providers", "status", "test"])

    assert result.exit_code == 0
    assert "progressing" in result.output
    assert "no" in result.output  # not healthy


def test_status_handles_failed_deployment(cli_runner, mock_pragma_client):
    """Status command shows failed status with error message."""
    mock_pragma_client.get_deployment_status.return_value = ProviderStatus(
        status=DeploymentStatus.FAILED,
        version="20250114.170000",
        healthy=False,
    )

    result = cli_runner.invoke(app, ["providers", "status", "test"])

    assert result.exit_code == 0
    assert "failed" in result.output
    assert "no" in result.output  # not healthy


def test_list_providers_displays_table(cli_runner, mock_pragma_client):
    """List command displays providers in a formatted table."""
    mock_pragma_client.list_providers.return_value = [
        ProviderInfo(
            provider_id="postgres",
            current_version="20250114.120000",
            deployment_status=DeploymentStatus.AVAILABLE,
            updated_at=datetime(2025, 1, 14, 12, 0, 0),
        ),
        ProviderInfo(
            provider_id="redis",
            current_version="20250114.100000",
            deployment_status=DeploymentStatus.PROGRESSING,
            updated_at=datetime(2025, 1, 14, 10, 0, 0),
        ),
    ]

    result = cli_runner.invoke(app, ["providers", "list"])

    assert result.exit_code == 0
    assert "postgres" in result.output
    assert "20250114.120000" in result.output
    assert "running" in result.output
    assert "redis" in result.output
    assert "deploying" in result.output


def test_list_providers_handles_empty_list(cli_runner, mock_pragma_client):
    """List command shows message when no providers exist."""
    mock_pragma_client.list_providers.return_value = []

    result = cli_runner.invoke(app, ["providers", "list"])

    assert result.exit_code == 0
    assert "No providers found" in result.output


def test_list_providers_handles_not_deployed(cli_runner, mock_pragma_client):
    """List command shows 'not deployed' for providers without deployments."""
    mock_pragma_client.list_providers.return_value = [
        ProviderInfo(
            provider_id="test",
            current_version=None,
            deployment_status=None,
            updated_at=None,
        ),
    ]

    result = cli_runner.invoke(app, ["providers", "list"])

    assert result.exit_code == 0
    assert "test" in result.output
    assert "not deployed" in result.output or "never deployed" in result.output


def test_list_providers_requires_auth(cli_runner, mock_pragma_client):
    """List command fails without authentication."""
    mock_pragma_client._auth = None

    result = cli_runner.invoke(app, ["providers", "list"])

    assert result.exit_code == 1
    assert "Authentication required" in result.output


def test_list_providers_handles_failed_status(cli_runner, mock_pragma_client):
    """List command shows failed status for providers with failed deployments."""
    mock_pragma_client.list_providers.return_value = [
        ProviderInfo(
            provider_id="broken",
            current_version="20250114.120000",
            deployment_status=DeploymentStatus.FAILED,
            updated_at=datetime(2025, 1, 14, 12, 0, 0),
        ),
    ]

    result = cli_runner.invoke(app, ["providers", "list"])

    assert result.exit_code == 0
    assert "broken" in result.output
    assert "failed" in result.output


# --- Tests for --output/-o flag ---


def test_list_providers_json_output(cli_runner, mock_pragma_client):
    """List command outputs JSON when -o json is specified."""
    mock_pragma_client.list_providers.return_value = [
        ProviderInfo(
            provider_id="postgres",
            current_version="20250114.120000",
            deployment_status=DeploymentStatus.AVAILABLE,
            updated_at=datetime(2025, 1, 14, 12, 0, 0, tzinfo=UTC),
        ),
        ProviderInfo(
            provider_id="redis",
            current_version="20250114.100000",
            deployment_status=DeploymentStatus.PROGRESSING,
            updated_at=datetime(2025, 1, 14, 10, 0, 0, tzinfo=UTC),
        ),
    ]

    result = cli_runner.invoke(app, ["providers", "list", "-o", "json"])

    assert result.exit_code == 0
    data = json.loads(result.output)
    assert isinstance(data, list)
    assert len(data) == 2
    assert data[0]["provider_id"] == "postgres"
    assert data[0]["current_version"] == "20250114.120000"
    assert data[0]["deployment_status"] == "available"
    assert data[1]["provider_id"] == "redis"


def test_list_providers_yaml_output(cli_runner, mock_pragma_client):
    """List command outputs YAML when --output yaml is specified."""
    mock_pragma_client.list_providers.return_value = [
        ProviderInfo(
            provider_id="postgres",
            current_version="20250114.120000",
            deployment_status=DeploymentStatus.AVAILABLE,
            updated_at=datetime(2025, 1, 14, 12, 0, 0, tzinfo=UTC),
        ),
    ]

    result = cli_runner.invoke(app, ["providers", "list", "--output", "yaml"])

    assert result.exit_code == 0
    data = yaml.safe_load(result.output)
    assert isinstance(data, list)
    assert len(data) == 1
    assert data[0]["provider_id"] == "postgres"


def test_status_json_output(cli_runner, mock_pragma_client):
    """Status command outputs JSON when -o json is specified."""
    mock_pragma_client.get_deployment_status.return_value = ProviderStatus(
        status=DeploymentStatus.AVAILABLE,
        version="20250114.153045",
        updated_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
        healthy=True,
    )

    result = cli_runner.invoke(app, ["providers", "status", "test", "-o", "json"])

    assert result.exit_code == 0
    data = json.loads(result.output)
    assert data["provider_id"] == "test"
    assert data["status"] == "available"
    assert data["healthy"] is True


def test_status_yaml_output(cli_runner, mock_pragma_client):
    """Status command outputs YAML when --output yaml is specified."""
    mock_pragma_client.get_deployment_status.return_value = ProviderStatus(
        status=DeploymentStatus.PROGRESSING,
        version="20250114.160000",
        healthy=False,
    )

    result = cli_runner.invoke(app, ["providers", "status", "test", "--output", "yaml"])

    assert result.exit_code == 0
    data = yaml.safe_load(result.output)
    assert data["provider_id"] == "test"
    assert data["status"] == "progressing"
    assert data["healthy"] is False


# --- Tests for publish command ---


def test_publish_success(cli_runner, provider_project, mock_pragma_client):
    """Publish creates tarball, calls publish API, and polls build status."""
    publish_result = mock_pragma_client.publish_store_provider.return_value
    publish_result.provider_name = "test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    build_status = mock_pragma_client.get_store_build_status.return_value
    build_status.status = "published"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0"])

    assert result.exit_code == 0
    assert "Publishing provider: test" in result.output
    assert "Created tarball:" in result.output
    assert "Published:" in result.output
    assert "Build successful:" in result.output

    mock_pragma_client.publish_store_provider.assert_called_once()
    call_args = mock_pragma_client.publish_store_provider.call_args
    assert call_args[0][0] == "test"
    assert isinstance(call_args[0][1], bytes)
    assert call_args[0][2] == "1.0.0"
    assert call_args[1]["changelog"] is None
    assert call_args[1]["force"] is False


def test_publish_force(cli_runner, provider_project, mock_pragma_client):
    """Publish with --force passes force flag to SDK."""
    publish_result = mock_pragma_client.publish_store_provider.return_value
    publish_result.provider_name = "test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    build_status = mock_pragma_client.get_store_build_status.return_value
    build_status.status = "published"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--force"])

    assert result.exit_code == 0
    call_args = mock_pragma_client.publish_store_provider.call_args
    assert call_args[1]["force"] is True


def test_publish_duplicate_hash(cli_runner, provider_project, mock_pragma_client):
    """Publish handles 409 (duplicate source hash) with helpful message."""
    mock_response = httpx.Response(409, json={"detail": "Duplicate source hash"})
    mock_pragma_client.publish_store_provider.side_effect = httpx.HTTPStatusError(
        "Conflict", request=httpx.Request("POST", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0"])

    assert result.exit_code == 1
    assert "source hash already exists" in result.output
    assert "--force" in result.output


def test_publish_no_wait(cli_runner, provider_project, mock_pragma_client):
    """Publish with --no-wait returns immediately after publish."""
    publish_result = mock_pragma_client.publish_store_provider.return_value
    publish_result.provider_name = "test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--no-wait"])

    assert result.exit_code == 0
    assert "Build running in background" in result.output
    mock_pragma_client.get_store_build_status.assert_not_called()
