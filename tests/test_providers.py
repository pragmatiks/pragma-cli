"""Tests for CLI providers commands (unified provider store)."""

from __future__ import annotations

import json
import tarfile
from datetime import UTC, datetime
from io import BytesIO

import httpx
import pytest
import yaml
from pragma_sdk import (
    DeploymentResult,
    DeploymentStatus,
)
from pytest_mock import MockerFixture
from typer.testing import CliRunner

from pragma_cli.commands.providers import (
    DEFAULT_TEMPLATE_URL,
    TARBALL_EXCLUDES,
    create_tarball,
    detect_provider_package,
    get_template_source,
    read_pragma_metadata,
)
from pragma_cli.main import app


@pytest.fixture
def cli_runner():
    return CliRunner()


@pytest.fixture
def template_path(monkeypatch, tmp_path):
    """Create and use a minimal Copier template for testing.

    Creates a self-contained template in a temp directory so tests
    don't depend on external template repos.
    """
    template_dir = tmp_path / "template"
    template_dir.mkdir()

    copier_yml = template_dir / "copier.yml"
    copier_yml.write_text("""name:
  type: str
  help: Provider name
description:
  type: str
  default: "A Pragmatiks provider"
author_name:
  type: str
  default: "Test Author"
author_email:
  type: str
  default: "test@example.com"

_subdirectory: template
""")

    tpl_dir = template_dir / "template"
    tpl_dir.mkdir()

    (tpl_dir / "pyproject.toml.jinja").write_text("""[project]
name = "{{ name }}-provider"
version = "0.1.0"
description = "{{ description }}"
dependencies = ["pragmatiks-sdk>=0.1.0"]

[project.optional-dependencies]
dev = ["pytest"]
""")

    (tpl_dir / "README.md.jinja").write_text("""# {{ name }}-provider

{{ description }}
""")

    src_dir = tpl_dir / "src" / "{{ name }}_provider"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""{{ name }} provider."""\n')

    resources_dir = src_dir / "resources"
    resources_dir.mkdir()
    (resources_dir / "__init__.py").write_text('"""Resource definitions."""\n')

    tests_dir = tpl_dir / "tests"
    tests_dir.mkdir()
    (tests_dir / "conftest.py").write_text('"""Test configuration."""\nimport pytest\n')

    (tpl_dir / ".copier-answers.yml.jinja").write_text("""# This file was auto-generated by Copier
_src_path: {{ _copier_conf.src_path }}
name: {{ name }}
description: {{ description }}
author_name: {{ author_name }}
author_email: {{ author_email }}
""")

    monkeypatch.setenv("PRAGMA_PROVIDER_TEMPLATE", str(template_dir))
    return template_dir


@pytest.fixture
def mock_pragma_client(mocker: MockerFixture):
    """Mock get_client for provider commands."""
    mock_client = mocker.Mock()
    mock_client._auth = mocker.Mock()
    mocker.patch("pragma_cli.commands.providers.get_client", return_value=mock_client)
    return mock_client


@pytest.fixture
def provider_project(tmp_path, monkeypatch):
    """Create a minimal provider project structure."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text('[project]\nname = "test-provider"')

    src_dir = tmp_path / "src" / "test_provider"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text("")
    (src_dir / "resources.py").write_text("# Resources go here")

    monkeypatch.chdir(tmp_path)
    return tmp_path


# ---------------------------------------------------------------------------
# Template and scaffolding tests
# ---------------------------------------------------------------------------


def test_get_template_source_uses_env_variable(monkeypatch):
    """Returns environment variable value when set."""
    monkeypatch.setenv("PRAGMA_PROVIDER_TEMPLATE", "/custom/template/path")
    assert get_template_source() == "/custom/template/path"


def test_get_template_source_default():
    """Default template URL is GitHub."""
    assert DEFAULT_TEMPLATE_URL == "gh:pragmatiks/pragma-providers"


def test_init_creates_project_structure(cli_runner, tmp_path, template_path):
    """Init creates complete project structure with all expected files."""
    result = cli_runner.invoke(
        app,
        ["providers", "init", "mycompany", "--output", str(tmp_path / "mycompany-provider"), "--defaults"],
    )
    assert result.exit_code == 0

    project_dir = tmp_path / "mycompany-provider"
    assert project_dir.exists()
    assert (project_dir / "pyproject.toml").exists()
    assert (project_dir / "README.md").exists()
    assert (project_dir / ".copier-answers.yml").exists()
    assert (project_dir / "src" / "mycompany_provider" / "__init__.py").exists()
    assert (project_dir / "src" / "mycompany_provider" / "resources" / "__init__.py").exists()
    assert (project_dir / "tests" / "conftest.py").exists()

    pyproject = (project_dir / "pyproject.toml").read_text()
    assert "pragmatiks-sdk" in pyproject

    assert "uv sync" in result.stdout
    assert "pragma providers publish" in result.stdout


def test_init_fails_if_directory_exists(cli_runner, tmp_path, template_path):
    """Init fails if target directory already exists."""
    existing_dir = tmp_path / "existing-provider"
    existing_dir.mkdir()

    result = cli_runner.invoke(app, ["providers", "init", "existing", "--output", str(existing_dir)])
    assert result.exit_code == 1
    assert "already exists" in result.output


def test_update_fails_without_answers_file(cli_runner, tmp_path):
    """Update fails when .copier-answers.yml is missing."""
    result = cli_runner.invoke(app, ["providers", "update", str(tmp_path)])
    assert result.exit_code == 1
    assert "not a Copier-generated project" in result.output


# ---------------------------------------------------------------------------
# Tarball creation tests
# ---------------------------------------------------------------------------


def test_create_tarball_includes_source_files(tmp_path):
    """Tarball includes provider source files."""
    src_dir = tmp_path / "src"
    src_dir.mkdir()
    (src_dir / "main.py").write_text("print('hello')")
    (tmp_path / "pyproject.toml").write_text('[project]\nname = "test"')

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert "./src/main.py" in names or "src/main.py" in names
        assert "./pyproject.toml" in names or "pyproject.toml" in names


def test_create_tarball_excludes_git_directory(tmp_path):
    """Tarball excludes .git directory."""
    (tmp_path / ".git").mkdir()
    (tmp_path / ".git" / "config").write_text("git config")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any(".git" in name for name in names)


def test_create_tarball_excludes_pycache(tmp_path):
    """Tarball excludes __pycache__ directories."""
    pycache = tmp_path / "__pycache__"
    pycache.mkdir()
    (pycache / "module.cpython-313.pyc").write_bytes(b"bytecode")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any("__pycache__" in name for name in names)


def test_create_tarball_excludes_venv(tmp_path):
    """Tarball excludes .venv directory."""
    venv = tmp_path / ".venv"
    venv.mkdir()
    (venv / "pyvenv.cfg").write_text("home = /usr/bin")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any(".venv" in name for name in names)


def test_create_tarball_excludes_pyc_files(tmp_path):
    """Tarball excludes .pyc files."""
    (tmp_path / "module.pyc").write_bytes(b"bytecode")
    (tmp_path / "main.py").write_text("print('hello')")

    tarball_bytes = create_tarball(tmp_path)

    with tarfile.open(fileobj=BytesIO(tarball_bytes), mode="r:gz") as tar:
        names = tar.getnames()
        assert not any(".pyc" in name for name in names)


def test_tarball_excludes_contains_common_patterns():
    """TARBALL_EXCLUDES contains expected patterns."""
    expected = {".git", "__pycache__", ".venv", ".env", "*.pyc", "dist", "build"}
    assert expected.issubset(TARBALL_EXCLUDES)


# ---------------------------------------------------------------------------
# Provider detection tests
# ---------------------------------------------------------------------------


def test_detect_provider_package_from_pyproject(tmp_path, monkeypatch):
    """Detects package name from pyproject.toml."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text('[project]\nname = "postgres-provider"')
    monkeypatch.chdir(tmp_path)

    result = detect_provider_package()
    assert result == "postgres_provider"


def test_detect_provider_package_returns_none_without_pyproject(tmp_path, monkeypatch):
    """Returns None when no pyproject.toml exists."""
    monkeypatch.chdir(tmp_path)
    result = detect_provider_package()
    assert result is None


# ---------------------------------------------------------------------------
# Publish command tests
# ---------------------------------------------------------------------------


def test_publish_success(cli_runner, provider_project, mock_pragma_client):
    """Publish creates tarball, calls publish API, and polls build status."""
    publish_result = mock_pragma_client.publish_provider.return_value
    publish_result.provider_name = "myorg/test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    build_status = mock_pragma_client.get_publish_status.return_value
    build_status.status = "published"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--org", "myorg"])

    assert result.exit_code == 0
    assert "Publishing provider: myorg/test" in result.output
    assert "Created tarball:" in result.output
    assert "Published:" in result.output
    assert "Build successful:" in result.output

    mock_pragma_client.publish_provider.assert_called_once()
    call_args = mock_pragma_client.publish_provider.call_args
    assert call_args[0][0] == "myorg/test"
    assert isinstance(call_args[0][1], bytes)
    assert call_args[0][2] == "1.0.0"
    assert call_args[1]["changelog"] is None
    assert call_args[1]["force"] is False


def test_publish_force(cli_runner, provider_project, mock_pragma_client):
    """Publish with --force passes force flag to SDK."""
    publish_result = mock_pragma_client.publish_provider.return_value
    publish_result.provider_name = "myorg/test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    build_status = mock_pragma_client.get_publish_status.return_value
    build_status.status = "published"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--org", "myorg", "--force"])

    assert result.exit_code == 0
    call_args = mock_pragma_client.publish_provider.call_args
    assert call_args[1]["force"] is True


def test_publish_duplicate_hash(cli_runner, provider_project, mock_pragma_client):
    """Publish handles 409 (duplicate source hash) with helpful message."""
    mock_response = httpx.Response(409, json={"detail": "Duplicate source hash"})
    mock_pragma_client.publish_provider.side_effect = httpx.HTTPStatusError(
        "Conflict", request=httpx.Request("POST", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--org", "myorg"])

    assert result.exit_code == 1
    assert "source hash already exists" in result.output
    assert "--force" in result.output


def test_publish_no_wait(cli_runner, provider_project, mock_pragma_client):
    """Publish with --no-wait returns immediately after publish."""
    publish_result = mock_pragma_client.publish_provider.return_value
    publish_result.provider_name = "myorg/test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--org", "myorg", "--no-wait"])

    assert result.exit_code == 0
    assert "Build running in background" in result.output
    mock_pragma_client.get_publish_status.assert_not_called()


def test_publish_fails_without_pyproject(cli_runner, tmp_path, monkeypatch):
    """Publish fails when no pyproject.toml exists."""
    monkeypatch.chdir(tmp_path)
    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--org", "myorg"])
    assert result.exit_code == 1
    assert "Could not detect provider package" in result.output


def test_publish_sends_metadata(cli_runner, provider_project, mock_pragma_client):
    """Publish reads metadata from [tool.pragma] and passes it to SDK."""
    pyproject = provider_project / "pyproject.toml"
    pyproject.write_text(
        '[project]\nname = "test-provider"\n\n'
        "[tool.pragma]\n"
        'display_name = "Test Provider"\n'
        'description = "A test provider"\n'
        'tags = ["test", "example"]\n'
    )

    publish_result = mock_pragma_client.publish_provider.return_value
    publish_result.provider_name = "myorg/test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    build_status = mock_pragma_client.get_publish_status.return_value
    build_status.status = "published"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--org", "myorg"])

    assert result.exit_code == 0

    call_kwargs = mock_pragma_client.publish_provider.call_args[1]
    assert call_kwargs["display_name"] == "Test Provider"
    assert call_kwargs["description"] == "A test provider"
    assert call_kwargs["tags"] == ["test", "example"]


def test_publish_without_metadata(cli_runner, provider_project, mock_pragma_client):
    """Publish works without [tool.pragma] metadata."""
    publish_result = mock_pragma_client.publish_provider.return_value
    publish_result.provider_name = "myorg/test"
    publish_result.version = "1.0.0"
    publish_result.status = "building"

    build_status = mock_pragma_client.get_publish_status.return_value
    build_status.status = "published"

    result = cli_runner.invoke(app, ["providers", "publish", "--version", "1.0.0", "--org", "myorg"])

    assert result.exit_code == 0

    call_kwargs = mock_pragma_client.publish_provider.call_args[1]
    assert "display_name" not in call_kwargs
    assert "description" not in call_kwargs
    assert "tags" not in call_kwargs


# ---------------------------------------------------------------------------
# read_pragma_metadata tests
# ---------------------------------------------------------------------------


def test_read_pragma_metadata_full(tmp_path):
    """Reads all metadata fields from [tool.pragma]."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text(
        '[project]\nname = "gcp-provider"\n\n'
        "[tool.pragma]\n"
        'provider = "pragmatiks/gcp"\n'
        'display_name = "Google Cloud Platform"\n'
        'description = "Official GCP provider"\n'
        'tags = ["cloud", "gcp"]\n'
    )

    metadata = read_pragma_metadata(tmp_path)

    assert metadata["display_name"] == "Google Cloud Platform"
    assert metadata["description"] == "Official GCP provider"
    assert metadata["tags"] == ["cloud", "gcp"]


def test_read_pragma_metadata_partial(tmp_path):
    """Reads only provided metadata fields."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text('[project]\nname = "test-provider"\n\n[tool.pragma]\ndisplay_name = "Test"\n')

    metadata = read_pragma_metadata(tmp_path)

    assert metadata["display_name"] == "Test"
    assert "description" not in metadata
    assert "tags" not in metadata


def test_read_pragma_metadata_no_section(tmp_path):
    """Returns empty dict when [tool.pragma] is missing."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text('[project]\nname = "test-provider"')

    metadata = read_pragma_metadata(tmp_path)

    assert metadata == {}


def test_read_pragma_metadata_no_pyproject(tmp_path):
    """Returns empty dict when pyproject.toml is missing."""
    metadata = read_pragma_metadata(tmp_path)
    assert metadata == {}


def test_read_pragma_metadata_tags_not_list(tmp_path):
    """Ignores tags when value is a string instead of a TOML array."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text(
        '[project]\nname = "test-provider"\n\n[tool.pragma]\ndisplay_name = "Test"\ntags = "cloud,gcp"\n'
    )

    metadata = read_pragma_metadata(tmp_path)

    assert metadata["display_name"] == "Test"
    assert "tags" not in metadata


def test_read_pragma_metadata_tags_mixed_types(tmp_path):
    """Ignores tags when list contains non-string elements."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text(
        '[project]\nname = "test-provider"\n\n[tool.pragma]\ndisplay_name = "Test"\ntags = ["ok", 1]\n'
    )

    metadata = read_pragma_metadata(tmp_path)

    assert metadata["display_name"] == "Test"
    assert "tags" not in metadata


def test_read_pragma_metadata_display_name_not_string(tmp_path):
    """Ignores display_name when value is not a string."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text(
        '[project]\nname = "test-provider"\n\n[tool.pragma]\ndisplay_name = 42\ndescription = "A provider"\n'
    )

    metadata = read_pragma_metadata(tmp_path)

    assert "display_name" not in metadata
    assert metadata["description"] == "A provider"


def test_read_pragma_metadata_description_not_string(tmp_path):
    """Ignores description when value is not a string."""
    pyproject = tmp_path / "pyproject.toml"
    pyproject.write_text(
        '[project]\nname = "test-provider"\n\n[tool.pragma]\ndisplay_name = "Test"\ndescription = 99\n'
    )

    metadata = read_pragma_metadata(tmp_path)

    assert metadata["display_name"] == "Test"
    assert "description" not in metadata


# ---------------------------------------------------------------------------
# Install command tests
# ---------------------------------------------------------------------------


def _make_provider_summary(
    mocker: MockerFixture,
    name: str = "qdrant",
    display_name: str = "Qdrant",
    trust_tier: str = "official",
    latest_version: str = "1.0.0",
    install_count: int = 42,
    tags: list[str] | None = None,
):
    provider = mocker.Mock()
    provider.name = name
    provider.display_name = display_name
    provider.trust_tier = trust_tier
    provider.latest_version = latest_version
    provider.install_count = install_count
    provider.tags = tags or ["vector", "ml"]
    provider.author = mocker.Mock()
    provider.author.org_name = "Pragmatiks"
    provider.description = f"A {name} provider"
    return provider


def _make_paginated_response(mocker: MockerFixture, items, total=None):
    response = mocker.Mock()
    response.items = items
    response.total = total if total is not None else len(items)
    response.limit = 20
    response.offset = 0
    return response


def _make_store_detail(mocker: MockerFixture, provider=None, versions=None):
    detail = mocker.Mock()
    detail.provider = provider or mocker.Mock()
    detail.versions = versions or []
    return detail


def _make_version(mocker: MockerFixture, version="1.0.0", status="published", runtime_version="0.5.0"):
    v = mocker.Mock()
    v.version = version
    v.status = status
    v.runtime_version = runtime_version
    v.published_at = "2026-02-01T10:00:00Z"
    v.changelog = "Initial release"
    return v


def _make_installed_provider(
    mocker: MockerFixture,
    name: str = "qdrant",
    version: str = "1.0.0",
    upgrade_policy: str = "manual",
    resource_tier: str = "standard",
    upgrade_available: bool = False,
    latest_version: str | None = None,
):
    p = mocker.Mock()
    p.store_provider_name = name
    p.installed_version = version
    p.upgrade_policy = upgrade_policy
    p.resource_tier = resource_tier
    p.installed_at = "2026-02-01T10:00:00Z"
    p.upgrade_available = upgrade_available
    p.latest_version = latest_version
    return p


def test_install_success(cli_runner, mock_pragma_client, mocker):
    """Install command installs provider with confirmation."""
    provider = _make_provider_summary(mocker, name="qdrant", display_name="Qdrant")
    detail = _make_store_detail(mocker, provider=provider)
    mock_pragma_client.get_provider.return_value = detail

    installed = mocker.Mock()
    installed.store_provider_name = "qdrant"
    installed.installed_version = "1.0.0"
    mock_pragma_client.install_provider.return_value = installed

    result = cli_runner.invoke(app, ["providers", "install", "qdrant"], input="y\n")

    assert result.exit_code == 0
    assert "Installed" in result.output
    assert "qdrant" in result.output
    assert "1.0.0" in result.output
    mock_pragma_client.install_provider.assert_called_once_with(
        "qdrant",
        version=None,
        resource_tier="standard",
        upgrade_policy="manual",
    )


def test_install_yes_flag(cli_runner, mock_pragma_client, mocker):
    """Install command skips confirmation with --yes."""
    provider = _make_provider_summary(mocker, name="qdrant")
    detail = _make_store_detail(mocker, provider=provider)
    mock_pragma_client.get_provider.return_value = detail

    installed = mocker.Mock()
    installed.store_provider_name = "qdrant"
    installed.installed_version = "1.0.0"
    mock_pragma_client.install_provider.return_value = installed

    result = cli_runner.invoke(app, ["providers", "install", "qdrant", "-y"])

    assert result.exit_code == 0
    assert "Installed" in result.output
    mock_pragma_client.install_provider.assert_called_once()


def test_install_already_installed(cli_runner, mock_pragma_client, mocker):
    """Install command handles 409 (already installed)."""
    provider = _make_provider_summary(mocker, name="qdrant")
    detail = _make_store_detail(mocker, provider=provider)
    mock_pragma_client.get_provider.return_value = detail

    mock_response = httpx.Response(409, json={"detail": "Already installed"})
    mock_pragma_client.install_provider.side_effect = httpx.HTTPStatusError(
        "Conflict", request=httpx.Request("POST", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "install", "qdrant", "-y"])

    assert result.exit_code == 1
    assert "already installed" in result.output


# ---------------------------------------------------------------------------
# Uninstall command tests
# ---------------------------------------------------------------------------


def test_uninstall_success(cli_runner, mock_pragma_client):
    """Uninstall command removes provider with confirmation."""
    mock_pragma_client.uninstall_provider.return_value = None

    result = cli_runner.invoke(app, ["providers", "uninstall", "qdrant"], input="y\n")

    assert result.exit_code == 0
    assert "Uninstalled" in result.output
    assert "qdrant" in result.output
    mock_pragma_client.uninstall_provider.assert_called_once_with("qdrant", cascade=False)


def test_uninstall_yes_flag(cli_runner, mock_pragma_client):
    """Uninstall command skips confirmation with --yes."""
    mock_pragma_client.uninstall_provider.return_value = None

    result = cli_runner.invoke(app, ["providers", "uninstall", "qdrant", "--yes"])

    assert result.exit_code == 0
    assert "Uninstalled" in result.output
    mock_pragma_client.uninstall_provider.assert_called_once_with("qdrant", cascade=False)


def test_uninstall_has_resources(cli_runner, mock_pragma_client):
    """Uninstall command handles 409 (has resources)."""
    mock_response = httpx.Response(409, json={"detail": "Provider has active resources"})
    mock_pragma_client.uninstall_provider.side_effect = httpx.HTTPStatusError(
        "Conflict", request=httpx.Request("DELETE", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "uninstall", "qdrant", "--yes"])

    assert result.exit_code == 1
    assert "active resources" in result.output
    assert "--cascade" in result.output


# ---------------------------------------------------------------------------
# Upgrade command tests
# ---------------------------------------------------------------------------


def test_upgrade_success(cli_runner, mock_pragma_client, mocker):
    """Upgrade command upgrades provider."""
    upgraded = mocker.Mock()
    upgraded.installed_version = "2.0.0"
    mock_pragma_client.upgrade_provider.return_value = upgraded

    result = cli_runner.invoke(app, ["providers", "upgrade", "qdrant", "-y"])

    assert result.exit_code == 0
    assert "Upgraded" in result.output
    assert "2.0.0" in result.output
    mock_pragma_client.upgrade_provider.assert_called_once_with("qdrant", target_version=None)


def test_upgrade_already_on_version(cli_runner, mock_pragma_client):
    """Upgrade command handles 409 (already on version)."""
    mock_response = httpx.Response(409, json={"detail": "Already on version"})
    mock_pragma_client.upgrade_provider.side_effect = httpx.HTTPStatusError(
        "Conflict", request=httpx.Request("POST", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "upgrade", "qdrant", "-y"])

    assert result.exit_code == 1
    assert "already on the requested version" in result.output


# ---------------------------------------------------------------------------
# List command tests (store browsing)
# ---------------------------------------------------------------------------


def test_list_table(cli_runner, mock_pragma_client, mocker):
    """List command displays providers in a formatted table."""
    providers = [
        _make_provider_summary(mocker, name="qdrant", display_name="Qdrant", trust_tier="official"),
        _make_provider_summary(mocker, name="postgres", display_name="PostgreSQL", trust_tier="verified"),
    ]
    mock_pragma_client.list_providers.return_value = _make_paginated_response(mocker, providers)

    result = cli_runner.invoke(app, ["providers", "list"])

    assert result.exit_code == 0
    assert "qdrant" in result.output
    assert "Qdrant" in result.output
    assert "official" in result.output
    assert "postgres" in result.output
    assert "PostgreSQL" in result.output
    assert "verified" in result.output
    assert "Showing 1-2 of 2 providers" in result.output


def test_list_json(cli_runner, mock_pragma_client, mocker):
    """List command outputs JSON format."""
    providers = [
        _make_provider_summary(mocker, name="qdrant"),
    ]
    mock_pragma_client.list_providers.return_value = _make_paginated_response(mocker, providers)

    result = cli_runner.invoke(app, ["providers", "list", "-o", "json"])

    assert result.exit_code == 0
    data = json.loads(result.output)
    assert isinstance(data, list)
    assert len(data) == 1
    assert data[0]["name"] == "qdrant"
    assert data[0]["trust_tier"] == "official"


def test_list_with_query(cli_runner, mock_pragma_client, mocker):
    """List command passes query filter to SDK."""
    providers = [
        _make_provider_summary(mocker, name="postgres", display_name="PostgreSQL"),
    ]
    mock_pragma_client.list_providers.return_value = _make_paginated_response(mocker, providers)

    result = cli_runner.invoke(app, ["providers", "list", "--query", "postgres"])

    assert result.exit_code == 0
    assert "postgres" in result.output
    mock_pragma_client.list_providers.assert_called_once_with(
        query="postgres",
        scope=None,
        trust_tier=None,
        tags=None,
        limit=20,
        offset=0,
    )


def test_list_with_tags(cli_runner, mock_pragma_client, mocker):
    """List command passes tags and trust tier filter to SDK."""
    providers = [
        _make_provider_summary(mocker, name="qdrant", trust_tier="official"),
    ]
    mock_pragma_client.list_providers.return_value = _make_paginated_response(mocker, providers)

    result = cli_runner.invoke(
        app, ["providers", "list", "--trust-tier", "official", "--tags", "vector,ml", "--limit", "10"]
    )

    assert result.exit_code == 0
    mock_pragma_client.list_providers.assert_called_once_with(
        query=None,
        scope=None,
        trust_tier="official",
        tags=["vector", "ml"],
        limit=10,
        offset=0,
    )


def test_list_with_scope(cli_runner, mock_pragma_client, mocker):
    """List command passes scope filter to SDK."""
    providers = [
        _make_provider_summary(mocker, name="qdrant", trust_tier="official"),
    ]
    mock_pragma_client.list_providers.return_value = _make_paginated_response(mocker, providers)

    result = cli_runner.invoke(app, ["providers", "list", "--scope", "public"])

    assert result.exit_code == 0
    mock_pragma_client.list_providers.assert_called_once_with(
        query=None,
        scope="public",
        trust_tier=None,
        tags=None,
        limit=20,
        offset=0,
    )


def test_list_empty(cli_runner, mock_pragma_client, mocker):
    """List command shows message when no providers found."""
    mock_pragma_client.list_providers.return_value = _make_paginated_response(mocker, [])

    result = cli_runner.invoke(app, ["providers", "list"])

    assert result.exit_code == 0
    assert "No providers found" in result.output


def test_list_query_no_results(cli_runner, mock_pragma_client, mocker):
    """List command shows query-specific message for no results."""
    mock_pragma_client.list_providers.return_value = _make_paginated_response(mocker, [])

    result = cli_runner.invoke(app, ["providers", "list", "--query", "nonexistent"])

    assert result.exit_code == 0
    assert "No providers found matching 'nonexistent'" in result.output


# ---------------------------------------------------------------------------
# List --installed tests
# ---------------------------------------------------------------------------


def test_list_installed_table(cli_runner, mock_pragma_client, mocker):
    """List --installed displays providers with upgrade indicators."""
    providers = [
        _make_installed_provider(
            mocker, name="qdrant", version="1.0.0", upgrade_available=True, latest_version="2.0.0"
        ),
        _make_installed_provider(mocker, name="postgres", version="3.1.0", upgrade_available=False),
    ]
    mock_pragma_client.list_installed_providers.return_value = providers

    result = cli_runner.invoke(app, ["providers", "list", "--installed"])

    assert result.exit_code == 0
    assert "qdrant" in result.output
    assert "1.0.0" in result.output
    assert "postgres" in result.output
    assert "3.1.0" in result.output
    assert "2.0.0" in result.output


def test_list_installed_empty(cli_runner, mock_pragma_client):
    """List --installed shows message when nothing installed."""
    mock_pragma_client.list_installed_providers.return_value = []

    result = cli_runner.invoke(app, ["providers", "list", "--installed"])

    assert result.exit_code == 0
    assert "No providers installed" in result.output


# ---------------------------------------------------------------------------
# Info command tests
# ---------------------------------------------------------------------------


def test_info_table(cli_runner, mock_pragma_client, mocker):
    """Info command displays provider details with versions."""
    provider = _make_provider_summary(mocker, name="qdrant", display_name="Qdrant")
    provider.readme = "# Qdrant Provider"
    provider.created_at = "2026-01-01T00:00:00Z"
    provider.updated_at = "2026-02-01T00:00:00Z"
    versions = [
        _make_version(mocker, version="1.0.0", status="published"),
        _make_version(mocker, version="0.9.0", status="published"),
    ]
    detail = _make_store_detail(mocker, provider=provider, versions=versions)
    mock_pragma_client.get_provider.return_value = detail

    result = cli_runner.invoke(app, ["providers", "info", "qdrant"])

    assert result.exit_code == 0
    assert "qdrant" in result.output
    assert "Qdrant" in result.output
    assert "official" in result.output
    assert "1.0.0" in result.output
    assert "0.9.0" in result.output
    assert "published" in result.output


def test_info_not_found(cli_runner, mock_pragma_client):
    """Info command handles 404 error."""
    mock_response = httpx.Response(404, json={"detail": "Not found"})
    mock_pragma_client.get_provider.side_effect = httpx.HTTPStatusError(
        "Not found", request=httpx.Request("GET", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "info", "nonexistent"])

    assert result.exit_code == 1
    assert "not found" in result.output


# ---------------------------------------------------------------------------
# Deploy command tests
# ---------------------------------------------------------------------------


def test_deploy_success(cli_runner, mock_pragma_client):
    """Deploy command deploys a provider."""
    mock_pragma_client.deploy_provider.return_value = DeploymentResult(
        deployment_name="test-provider",
        status=DeploymentStatus.PROGRESSING,
        available_replicas=1,
        ready_replicas=0,
        version="20250114.153045",
        image="gcr.io/pragmatiks-prod/test-provider:latest",
        updated_at=None,
        message=None,
    )

    result = cli_runner.invoke(app, ["providers", "deploy", "test"])

    assert result.exit_code == 0
    assert "Deployment started:" in result.output
    assert "test-provider" in result.output
    assert "0/1" in result.output


# ---------------------------------------------------------------------------
# Status command tests
# ---------------------------------------------------------------------------


def test_status_displays_deployment_info(cli_runner, mock_pragma_client):
    """Status command displays deployment information."""
    mock_pragma_client.get_deployment_status.return_value = DeploymentResult(
        deployment_name="test-provider",
        status=DeploymentStatus.AVAILABLE,
        available_replicas=1,
        ready_replicas=1,
        version="20250114.153045",
        image="gcr.io/pragmatiks-prod/test-provider:latest",
        updated_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
        message=None,
    )

    result = cli_runner.invoke(app, ["providers", "status", "test"])

    assert result.exit_code == 0
    assert "Provider:" in result.output
    assert "test" in result.output
    assert "available" in result.output
    assert "2025-01-14" in result.output
    assert "test-provider" in result.output
    assert "1/1" in result.output


def test_status_handles_not_found(cli_runner, mock_pragma_client):
    """Status command handles deployment not found."""
    mock_response = httpx.Response(404, json={"detail": "Deployment not found"})
    mock_pragma_client.get_deployment_status.side_effect = httpx.HTTPStatusError(
        "Not found", request=httpx.Request("GET", "http://test"), response=mock_response
    )

    result = cli_runner.invoke(app, ["providers", "status", "nonexistent"])

    assert result.exit_code == 1
    assert "Deployment not found" in result.output


def test_status_handles_progressing_deployment(cli_runner, mock_pragma_client):
    """Status command shows progressing status correctly."""
    mock_pragma_client.get_deployment_status.return_value = DeploymentResult(
        deployment_name="test-provider",
        status=DeploymentStatus.PROGRESSING,
        available_replicas=1,
        ready_replicas=0,
        version="20250114.160000",
    )

    result = cli_runner.invoke(app, ["providers", "status", "test"])

    assert result.exit_code == 0
    assert "progressing" in result.output
    assert "0/1" in result.output


def test_status_handles_failed_deployment(cli_runner, mock_pragma_client):
    """Status command shows failed status with error message."""
    mock_pragma_client.get_deployment_status.return_value = DeploymentResult(
        deployment_name="test-provider",
        status=DeploymentStatus.FAILED,
        available_replicas=0,
        ready_replicas=0,
        version="20250114.170000",
        message="CrashLoopBackOff",
    )

    result = cli_runner.invoke(app, ["providers", "status", "test"])

    assert result.exit_code == 0
    assert "failed" in result.output
    assert "CrashLoopBackOff" in result.output


# ---------------------------------------------------------------------------
# Status output format tests
# ---------------------------------------------------------------------------


def test_status_json_output(cli_runner, mock_pragma_client):
    """Status command outputs JSON when -o json is specified."""
    mock_pragma_client.get_deployment_status.return_value = DeploymentResult(
        deployment_name="test-provider",
        status=DeploymentStatus.AVAILABLE,
        available_replicas=1,
        ready_replicas=1,
        version="20250114.153045",
        image="gcr.io/pragmatiks-prod/test-provider:latest",
        updated_at=datetime(2025, 1, 14, 15, 30, 45, tzinfo=UTC),
    )

    result = cli_runner.invoke(app, ["providers", "status", "test", "-o", "json"])

    assert result.exit_code == 0
    data = json.loads(result.output)
    assert data["provider_id"] == "test"
    assert data["status"] == "available"
    assert data["deployment_name"] == "test-provider"
    assert data["ready_replicas"] == 1


def test_status_yaml_output(cli_runner, mock_pragma_client):
    """Status command outputs YAML when --output yaml is specified."""
    mock_pragma_client.get_deployment_status.return_value = DeploymentResult(
        deployment_name="test-provider",
        status=DeploymentStatus.PROGRESSING,
        available_replicas=1,
        ready_replicas=0,
        version="20250114.160000",
    )

    result = cli_runner.invoke(app, ["providers", "status", "test", "--output", "yaml"])

    assert result.exit_code == 0
    data = yaml.safe_load(result.output)
    assert data["provider_id"] == "test"
    assert data["status"] == "progressing"
    assert data["deployment_name"] == "test-provider"


# ---------------------------------------------------------------------------
# Auth requirement tests
# ---------------------------------------------------------------------------


def test_list_installed_requires_auth(cli_runner, mock_pragma_client):
    """List --installed command fails without authentication."""
    mock_pragma_client._auth = None

    result = cli_runner.invoke(app, ["providers", "list", "--installed"])

    assert result.exit_code == 1
    assert "Authentication required" in result.output
